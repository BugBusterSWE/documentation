%\href{nome}{url}
\section{Processi primari}

	\subsection{Processo di fornitura}	
	\subsubsection{Oggetto del processo}
	L'oggetto del presente \glossaryItem{Processo} è la stesura dello \StudioDiFattibilita, compito
	di cui si occupa un \textit{Analista}.
	\subsubsection{Struttura dello \textit{Studio di Fattibilit\'a v\VersioneSF{}}}
		\begin{itemize}
			\item Capitolato scelto;
				\begin{enumerate}
					\item Descrizione
					\item Valutazione sul dominio del \glossaryItem{progetto}
					\item Motivazioni della scelta
				\end{enumerate}	
			\item Valutazioni sugli altri capitolati, con rispettivi aspetti positivi e negativi.
		\end{itemize}


	\subsection{Processo di sviluppo}
        \subsubsection{Scopo del processo}
        Lo scopo del presente \glossaryItem{processo} \`e la realizzazione di un elemento di sistema implementato come prodotto
        software. Il \glossaryItem{processo} in esame produce un software che soddisfa i requisiti architetturali, sottoposto
        in seguito alle attivit\`a di \glossaryItem{verifica} e \glossaryItem{validazione}.
        
        \subsubsection{Risultati principali del processo}
        Sono stati previsti i seguenti risultati positivi derivanti da una corretta implementazione del \textit{\glossaryItem{processo} di sviluppo}:

        \begin{itemize}
          \item Requisiti software ben delineati;
          \item Gli elementi tecnologici e di progettazione sono identificati;
          \item L'attivit\`a di codifica consiste in una mera traduzione dell'output proveniente dall'attivit\`a di progettazione,
            riducendo cos\`i i \glossaryItem{rischi} provenienti dalla libert\`a dei \glossaryItem{programmatori}.
        \end{itemize}
        
		\paragraph*{1. Attività di Analisi dei Requisiti}
			\paragraph*{Scopo}
				Gli analisti del gruppo dovranno ricavare i requisiti utili per il \glossaryItem{progetto}
				dal capitolato e dagli incontri con il proponente, avendo come obiettivo la
				stesura del documento \textit{Analisi dei Requisiti}.
			        %parlare di: IEEE 830-1998: Recommended Practice
			        %for Software Requirements Specifications (slide 32 in ING_REQUISITI)
			        Inotre la specifica dei requisiti dev'essere conforme ai principi dello standard \textit{IEEE 830-1998}, espressi in otto qualit\`a
			        essenziali:
				\begin{itemize}
				\item Priva di ambiguit\`a (UNAMBIGOUS);
				\item Corretta (CORRECT);
				\item Completa (COMPLETE);
				\item Verificabile (VERIFIABLE);
				\item Consistente (CONSISTENT);
				\item Modificabile (MODIFIABLE);
				\item Tracciabile (TRACEABLE);
				\item Ordinata per rilevanza (RANKED).
				\end{itemize}
			        %slide 40 di ING_REQUISITI: Cause di abbandono
			        La stesura di un'Analisi dei Requisiti di qualit\`a \`e cruciale, infatti
			        da un rapporto dello Standish Group del 1995 si nota come due delle cause primarie
			        di abbandono dei \glossaryItem{progetti} siano le seguenti:
				\begin{itemize}
				\item Requisiti incompleti;
				\item Volatilità di specifiche e requisiti.
				\end{itemize}
			
			
			%casi d'uso: si parte da 0 nella numerazione
			\paragraph*{Struttura del documento}
			Il documento prodotto dalla presente attivit\`a consister\`a in un elenco dei \glossaryItem{casi d'uso} individuati, 
                        ognuno avente la seguente forma:
				\begin{itemize}
				\item Codice identificativo: \textbf{UC-{X} x.y.z}
						\begin{itemize}
						\item \textbf{X}: rappresenta uno degli ambiti di riferimento individuati
						nell'Analisi dei Requisiti, in particolare:
							\begin{itemize}
							\item [] \textbf{U} = Ambito Utente;
							\item [] \textbf{S} = Ambito \glossaryItem{Super-Admin};
							\item [] \textbf{E} = Ambito Editor. 
							\end{itemize}
						\end{itemize}
				\item Titolo;
				\item Diagramma \glossaryItem{UML};
				\item \glossaryItem{Attori} primari;
				\item Scopo e descrizione;
				\item Precondizioni;
				\item Postcondizione;
				\item \glossaryItem{Scenario} principale;
                                \item Estensioni.
				\end{itemize}
			Saranno altresì esposti i requisiti, associati alle rispettive fonti, nella forma seguente:
				\begin{itemize}
				\item Codice identificativo: \textbf{R{X}{Y} x.y.z}
				\item Titolo;
				\item Descrizione;
                \item Fonti.
				\end{itemize}
			E viceversa:
				\begin{itemize}
				\item Fonte;
				\item Codice identificativo del requisito.
				\end{itemize}
			%parlare degli STRUMENTI utilizzati
			\paragraph*{Strumenti}
				Per i \glossaryItem{diagrammi} dei \glossaryItem{casi} d'uso verrà utilizzato il linguaggio \textit{UML 2.0},
				noto a tutti i membri del gruppo in quanto trattato durante il corso
				di \textit{Ingegneria del Software}.
				Si \`e scelto inoltre di adottare l'editor \glossaryItem{UML} \textit{Astah}.   %riferimento per astah
			
			
		\paragraph*{2. Attività di Progettazione}
			\paragraph*{Scopo}
		     %Costruzione a priori perseguendo la correttezza per costruzione
		     %invece che inseguendo la correttezza per correzione     <<  slide PROGETTAZIONE
		     %Procede dall'Analisi dei Requisiti   <<  slide PROGETTAZIONE	
		        La presente attivit\`a, che procede dall'Analisi dei Requisiti, persegue l'obiettivo
		        della correttezza del prodotto per costruzione, permettendo di ridurre al minimo le attività di correzione
		        in \glossaryItem{fase} di codifica.
                        I documenti elaborati in questa \glossaryItem{fase} sono:
                        \begin{itemize}
                        \item \glossaryItem{Specifica Tecnica}, documento proposto in sede di \textit{Revisione di Progettazione minima}, nel quale vengono individuate 
			 le componenti macroscopiche del sistema, suddivisione utile per garantire che il lavoro successivo proceda in modo parallelo e soddisfi i principi di ortogonalità;
                        \item \glossaryItem{Definizione di Prodotto}, documento che fornisce ai \glossaryItem{programmatori} tutte le direttive necessarie per la codifica;
					    esso descrive in dettaglio la progettazione del sistema, integrando quanto scritto nella Specifica Tecnica. Il documento specifica i diagrammi UML e le
					    definizioni delle classi. Viene proposto in sede di \textit{Revisione di Progettazione massima} oppure in sede di \textit{Revisione di Qualifica}.
                        \end{itemize}
		    %si useranno Design patterns
		        Per la progettazione del prodotto sarà opportuno utilizzare \glossaryItem{design pattern} globalmente affermati.
			I membri del gruppo hanno acquisito conoscenze approfondite di tali design pattern durante il corso di \textit{Ingegneria del Software}.
                 
                        %diagrammi \glossaryItem{UML} prodotti
                        \paragraph*{Diagrammi prodotti}
                        Nel corso di questa \glossaryItem{fase} verranno prodotti quattro tipi di \glossaryItem{diagrammi} \glossaryItem{UML}:
                        \begin{itemize}
                        \item \glossaryItem{Diagrammi} delle classi;
                        \item \glossaryItem{Diagrammi} dei \glossaryItem{package};
                        \item \glossaryItem{Diagrammi} di sequenza;
                        \item \glossaryItem{Diagrammi} di attivit\`a.
                        \end{itemize}
                        I tipi di \glossaryItem{diagrammi} sopra elencati andranno a far parte dei due documenti menzionati sopra.
		
			\paragraph*{Tracciamento dei componenti}
			Ogni requisito deve essere riferito al componente che lo soddisfa. Tramite questa operazione è possibile garantire che ogni requisito venga
			soddisfatto, inoltre questo aiuta nella misurazione del progresso dell'attività di progettazione.		
			
		 %parlare degli STRUMENTI utilizzati
		        \paragraph*{Strumenti}
		        Come per l'attivit\`a precedente e per gli stessi motivi, i membri del gruppo hanno stabilito l'utilizzo del linguaggio \glossaryItem{UML} 2.0 per i seguenti
		        \glossaryItem{diagrammi}:
		        \begin{itemize}
			\item \glossaryItem{Diagrammi} dei \glossaryItem{package}; 
			\item \glossaryItem{Diagrammi} delle \textit{classi};	
			\item \glossaryItem{Diagrammi} di \textit{attivit\`a}.
		        \end{itemize}
			 
		
		\paragraph*{3. Attività di Codifica}

                \paragraph*{Scopo}
                La presente attivit\`a ha come scopo la traduzione in \glossaryItem{codice sorgente} dei risultati ottenuti in sede
                di \glossaryItem{Specifica Tecnica} e di \glossaryItem{Definizione di Prodotto}.
                In sede di \textit{Revisione di Qualifica} \`e possibile fornire una visione precisa sulla attivit\`a.
                Per il codice \glossaryItem{Typescript} si \`e stabilito di adottare delle direttive proprie del gruppo, definite tramite l'uso di un lint.
                \paragraph*{Regole definite nel lint}
                Si \`e deciso di utilizzare il lint per Typescript, \textit{TsLint}, che permette di impostare regole di codifica controllate staticamente.
                Questo lint \`e configurabile tramite l'utilizzo di un file JSON, di cui sono state utilizzate le seguenti regole:
                \begin{itemize}

                \item \textit{member-access}: questa regola impone di dichiarare esplicitamente la visibilit\`a dei membri di una classe;
                \item \textit{member-ordering}: questa regola impone un ordinamento consistente dei membri delle classi, per fornire una lettura del codice pi\`u facile e maggiormente navigabile. In particolare, \`e stato deciso di scrivere prima le varibili e dopo i metodi, e per i metodi, prima quelli pubblici e poi quelli privati;
                \item \textit{no-any}: questa regola impedisce la dichiarazione di variabili di tipo \textit{any} nel codice Typescript, eliminando di fatto la non determinazione di tipo a \textit{static time};
                \item \textit{no-internal-module}: questa regole impedisce l'uso di moduli interni, che portano confusione all'interno del codice. \`E invece imposto l'utilizzo della \textit{keyword} \textit{namespace};
                \item \textit{no-var-requires}: questa regola impedisce l'utilizzo della \textit{keyword} Javascript \textit{require}, per favorire l'utilizzo della nuova \textit{keyword} \textit{import} introdotta da Typescript;
                \item \textit{typedef}: questa regola impone di definire i tipi per metodi di ritorno, parametri, definizioni di variabili e di membri di classi;
                \item \textit{typedef-whitespace}: questa regola impone di inserire degli spazi tra il tipo dichiarato e il suo nome, in maniera tale da aumentare la leggibilit\`a del codice;
                \item \textit{curly}: questa regola impone l'utilizzo di parentesi graffe anche per \textit{statements} condizionali con istruzioni da una riga. Questo permette una maggiore leggibilit\`a del codice e contribuisce a manterlo ordinato e a prevenire errori;
                \item \textit{no-bitwise}: questa regola disabilita l'utilizzo delle cosidette operazioni \textit{bitwise} all'interno di espressioni. Questo viene fatto poiché le operazioni bitwise sono spesso fonte di errore e degradano la leggibilit\`a e la manutenibilità del codice, rendendolo pi\`u confusionario.
                \item \textit{no-conditional-assignment}: questa regola impedisce di poter assegnare valori a una variabile all'interno di espressioni condizionali (di tipo \textit{do-while}, \textit{if}, \textit{for} e \textit{while}). Queste operazioni sono molto spesso pericolose e sono fonte di errori;
                \item \textit{no-duplicate-key}: questa regola impedisce la dichiarazioni di \textit{object literals} con la stessa chiave;
                \item \textit{no-duplicate-variable}: questa regola impedisce la dichiarazioni di variabile con lo stesso nome nello stesso \textit{scope}, evitando ridichiarazioni del compilatore e quindi evitando errori identificabili solamente a tempo di esecuzione;
                \item \textit{no-empty}: questa regola impedisce l'utilizzo di blocchi vuoti di codice, in quanto potrebbero indicare del codice mancante, non implementato (e fonte d'errore);
                \item \textit{no-eval}: questa regola impedisce l'uso della funzione \textit{eval()} in Typescript, in quanto \`e ritenuta pericolosa dal punto di vista della sicurezza e pu\`o permettere l'esecuzione arbitraria di codice passato come una stringa;
                \item \textit{no-null-keyword}: questa regola impedisce l'uso della \textit{keyword} \textit{null} in favore dell'utilizzo della \textit{keyword} \textit{undefined}. Questo permette di uniformare il codice con l'utilizzo di una sola \textit{keyword};
                \item \textit{no-string-literal}: questa regola impedisce l'accesso ad oggetti tramite \textit{string literals}, incoraggiando l'utilizzo delle propriet\`a di accesso di tipo fortemente tipate;
                \item \textit{no-swith-case-fall-through}: questa regola impedisce l'utilizzo di \textit{switch} senza l'utilizzo della \textit{keyword} \textit{break} per ogni caso. In questa maniera si evitano errori in cui tutti i casi successivi a quello voluto vengono eseguiti involontariamente;
                \item \textit{no-unreachable}: questa regola impedisce la scrittura di codice dopo gli \textit{statements: break, catch, throw, return}, che sarebbe non raggiungibile. In questa maniera \`e pi\`u facile riconoscere eventuali errori logici al programmatore;
                \item \textit{no-unused-expression}: questa regola impedisce la dichiarazione di oggetti senza un loro effettivo utilizzo. 
                \item \textit{no-use-before-declare}: questa regola impedisce l'utilizzo di variabili senza prima una loro dichiarazione. Questo tipo di codifica di solito porta a errori e all'inquinamento dello \textit{scope} globale, creando quindi confusione nel codice e una minore leggibilit\`a;
                \item \textit{no-var-keyword}: questa regola disabilita la dichiarazione di variabili tramite la \textit{keyword} \textit{var}, ma impone l'utilizzo di \textit{let} per la dichiarazione di variabili, come consigliato da Typescript;
                \item \textit{switch-default}: questa regola impone che quando uno \textit{switch} viene utilizzato sia sempre definito il caso \textit{default};
                \item \textit{use-strict}: questa regola impone l'utilizzo della \textit{keyword} \textit{use-strict} definita nello standard ECMAScript 5;
                \item \textit{eofline}: questa regola impone l'inserimento di una linea vuota alla fine del file, per seguire la convenzione UNIX;
                \item \textit{ident}: questa regola impone l'identazione tramite spazi e non tramite tabulazioni;
                \item \textit{max-line-length}: questa regola impone la lunghezza massima di una riga a 80 colonne. Questo aiuta a mantenere uniformit\`a al codice e ne facilita di molto la lettura;
                \item \textit{no-require-imports}: questa regola disabilita l'uso della \textit{keyword} \textit{require};
                \item \textit{no-trailing-whitespace}: questa regola impone che nelle righe vuote non siano presenti spazi o tabulazioni;
                \item \textit{trailing-comma}: questa regola impone l'utilizzo della virgola negli textit{array} e negli \textit{object literals};
                \item \textit{align}: questa regola impone che sia presente un allineamento uniforme tra le varie istruzioni del codice, per facilitarne la lettura;
                \item \textit{class-name}: questa regola impone che i nomi delle classi e delle interfacce seguano la notazione \textit{PascalCased};
                \item \textit{comment-format}: questa regola impone un determinato stile per i commenti. Tutti i commenti devono iniziare con uno spazio e devono iniziare con la lettera maiuscola. Questa regola tenta di dare uniformit\`a a tutti i commenti presenti nel codice;
                \item \textit{jsdoc-format}: questa regola impone lo stile \textit{JSDoc} per i commenti confacenti alla documentazione di una determinata classe o per un determinato metodo;
                \item \textit{one-line}: questa regola impone che una singola istruzione sia presente su una riga e non venga mandata a capo, per migliorare la lettura del codice;
                \item \textit{quotemark}: questa regola impone l'utilizzo di doppi apici durante la stesura di tutto il codice;
                \item \textit{semicolon}: questa regola impone l'utilizzo del punto e virgola alla fine di ogni istruzione in cui andrebbe posta. Questo permette di evitare errori in fase di codifica e di facilitare la lettura del codice;
                \item \textit{variable-name}: questa regola impone che i nomi delle variabili seguano la notazione \textit{camelCase}. Inoltre viene anche vietato che i nomi delle variabili corrispondano a eventuali \textit{keywords};
                  \item \textit{whitespace}: questa regola impone l'inserimento di spazi in vari punti del codice, facilitando la lettura dello stesso e aiutando a mantenere uno stile uniforme.
                \end{itemize}

                
                La scelta e l'utilizzo delle precedenti regole sono strettamente correlati alla teoria sull'\textit{Analisi Statica}, in quanto da essa si evince che:
                \begin{itemize}
		  \item L’adozione di \textit{standard} di codifica deve essere coerente con la scelta dei metodi di \glossaryItem{verifica} adottati,         
                     %<<< slide 30/30 di ANALISI_STATICA
		  \item L’\glossaryItem{efficacia} dei metodi di analisi statica \`e strettamente correlata alla qualit\`a di strutturazione del codice.
                \end{itemize}

		\paragraph*{\textit{10 regole d'oro}}
		Perseguendo l'obiettivo della semplificazione dell'analisi (sia statica sia dinamica),
           	i \glossaryItem{programmatori} del gruppo cercheranno di essere quanto più conformi possibile alle 10 regole
           	espresse nel documento \textit{The Power of 10: Rules for Developing Safety-Critical Code}, che riportiamo di seguito per comodità:
                	\begin{enumerate}
                        	\item \textit{Usare costrutti di controllo di flusso i più semplici possibile}
                        	\item \textit{Usare \glossaryItem{iterazioni} con limite superiore statico}
                        	\item \textit{Non usare allocazione dinamica di memoria dopo l'inizializzazione}
                        	\item \textit{Limitare la lunghezza di ogni singolo sottoprogramma a 60 linee}
                        	\item \textit{Controllare che tutti i parametri in ingresso e in uscita siano validi}
                        	\item \textit{Limitare al massimo la compilazione condizionale}
                        	\item \textit{Puntare ad un uso intensivo di asserzioni(almeno 2 per sottoprogramma)}
                        	\item \textit{Puntare al massimo livello architetturale di \textit{data hiding}}
                        	\item \textit{Limitare al massimo l'uso dei puntatori e il livello di dereferenziazione}
                        	\item \textit{Il codice va compilato da subito usando il compilatore nel modo più restrittivo}
			\end{enumerate}

                \paragraph*{Strumenti}
                Il gruppo ha stabilito di utilizzare i seguenti editor:
                \begin{itemize}
                  \item \textbf{Emacs}(\url{https://www.gnu.org/software/emacs/}) per la stesura del codice \LaTeX; 
                  \item \textbf{WebStorm}(\url{https://www.jetbrains.com/webstorm/}) per il codice \glossaryItem{Typescript}.
                \end{itemize}
