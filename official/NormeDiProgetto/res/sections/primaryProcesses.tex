%\href{nome}{url}
\section{Processi primari}

	\subsection{Processo di fornitura}	
	\subsubsection{Oggetto del processo}
	L'oggetto del presente \glossaryItem{processo} è la stesura dello \textit{Studio di Fattibilità}, compito
	di cui si occupa un \textit{Analista}. Il \textit{Responsabile di \glossaryItem{Progetto}} deve invece organizzare delle riunioni preventive, 
	per permettere lo scambio di opinioni tra i membri del gruppo sui capitolati proposti.
	\subsubsection{Struttura dello \textit{Studio di Fattibilità}}
		\begin{itemize}
			\item Capitolato scelto;
				\begin{enumerate}
					\item Descrizione;
					\item Valutazione sul dominio del \glossaryItem{progetto};
					\item Motivazioni della scelta.
				\end{enumerate}	
			\item Valutazioni sugli altri capitolati, con rispettivi aspetti positivi e negativi.
		\end{itemize}

	\subsection{Processo di sviluppo}
        \subsubsection{Scopo del processo}
        Lo scopo del presente \glossaryItem{processo} \`e la realizzazione di un elemento di sistema implementato come prodotto
        software. Il \glossaryItem{processo} in esame produce un software che soddisfa i requisiti architetturali, sottoposto
        in seguito alle attivit\`a di \glossaryItem{verifica} e \glossaryItem{validazione}.
        
        \subsubsection{Risultati principali del processo}
        Sono stati previsti i seguenti risultati positivi derivanti da una corretta implementazione del \textit{\glossaryItem{processo} di sviluppo}:

        \begin{itemize}
          \item Requisiti software ben delineati;
          \item Gli elementi tecnologici e di progettazione sono identificati;
          \item L'attivit\`a di codifica consiste in una mera traduzione dell'output proveniente dall'attivit\`a di progettazione,
            riducendo cos\`i i \glossaryItem{rischi} provenienti dalla libert\`a dei \glossaryItem{programmatori}.
        \end{itemize}
        
		\paragraph*{1. Attività di Analisi dei Requisiti}
			\paragraph*{Scopo}
				Gli analisti del gruppo dovranno ricavare i requisiti utili per il \glossaryItem{progetto}
				dal capitolato e dagli incontri con il proponente, avendo come obiettivo la
				stesura del documento \textit{Analisi dei Requisiti}.
			        %parlare di: IEEE 830-1998: Recommended Practice
			        %for Software Requirements Specifications (slide 32 in ING_REQUISITI)
			        Inoltre la specifica dei requisiti dev'essere conforme ai principi dello standard \textit{IEEE 830-1998}, espressi in otto qualit\`a
			        essenziali:
				\begin{itemize}
				\item Priva di ambiguit\`a (UNAMBIGOUS);
				\item Corretta (CORRECT);
				\item Completa (COMPLETE);
				\item Verificabile (VERIFIABLE);
				\item Consistente (CONSISTENT);
				\item Modificabile (MODIFIABLE);
				\item Tracciabile (TRACEABLE);
				\item Ordinata per rilevanza (RANKED).
				\end{itemize}
			        %slide 40 di ING_REQUISITI: Cause di abbandono
			        La stesura di un'Analisi dei Requisiti di qualit\`a \`e cruciale, infatti
			        da un rapporto dello \textit{Standish Group} del 1995 si nota come due delle cause primarie
			        di abbandono dei \glossaryItem{progetti} siano le seguenti:
				\begin{itemize}
				\item Requisiti incompleti;
				\item Volatilità di specifiche e requisiti.
				\end{itemize}
				Per analizzare e trovare i requisiti si utilizza la tecnica dei \glossaryItem{casi} d’uso. Il \glossaryItem{tracciamento} dei requisiti avviene 
			        tramite il software \textit{Tracy}.
			
			%casi d'uso: si parte da 0 nella numerazione
			\paragraph*{Struttura del documento}
			Il documento prodotto dalla presente attivit\`a consister\`a in un elenco dei \glossaryItem{casi d'uso} individuati, 
                        ognuno avente la seguente forma:
				\begin{itemize}
				\item Codice identificativo: \textbf{UC-{X} x.y.z} (la numerazione \textbf{x.y.z} potrebbe non essere continua nel caso in cui vengano
                                      rimossi alcuni dei \glossaryItem{casi} d'uso numerati precedentemente.)
						\begin{itemize}
						\item \textbf{X}: rappresenta uno degli ambiti di riferimento individuati
						nell'Analisi dei Requisiti, in particolare:
							\begin{itemize}
							\item [] \textbf{U} = Ambito Utente;
							\item [] \textbf{S} = Ambito \glossaryItem{Super-Admin};
							\item [] \textbf{E} = Ambito Editor. 
							\end{itemize}
						\end{itemize}
				\item Titolo;
				\item Diagramma \glossaryItem{UML};
				\item \glossaryItem{Attori} primari;
				\item Scopo e descrizione;
				\item Precondizioni;
				\item Postcondizione;
				\item \glossaryItem{Scenario} principale;
                                \item Estensioni.
				\end{itemize}

			Saranno altresì esposti i requisiti, associati alle rispettive fonti, nella forma seguente:
				\begin{itemize}
				\item Codice identificativo: \textbf{R{X}{Y} x.y.z}, dove:
				      \begin{itemize}
						\item \textbf{X} corrisponde alla tipologia del requisito e può assumere i seguenti valori:
							\begin{itemize}
								\item \textbf{1} = Funzionale;
								\item \textbf{2} = Prestazionale;
								\item \textbf{3} = Di Qualità;
								\item \textbf{4} = Vincolo.
							\end{itemize}
						\item \textbf{Y} corrisponde alla priorità del requisito e può assumere i seguenti valori:
							\begin{itemize}
								\item \textbf{O} = Obbligatorio;
								\item \textbf{D} = Desiderabile;
								\item \textbf{F} = Facoltativo o Opzionale.
							\end{itemize}
						\item \textbf{Gerarchia}: identifica la relazione gerarchica che c’è tra i requisiti di uno stesso
						tipo. Vi è dunque una struttura gerarchica per ogni tipologia di requisito.
						La numerazione \textbf{x.y.z} potrebbe non essere continua nel caso in cui vengano
						rimossi alcuni dei requisiti numerati precedentemente.
				      \end{itemize}
				\item Titolo;
				\item Descrizione;
                \item Fonti.
				\end{itemize}
			E viceversa:
				\begin{itemize}
				\item Fonte;
				\item Codice identificativo del requisito.
				\end{itemize}
			%parlare degli STRUMENTI utilizzati
			\paragraph*{Strumenti}
				Per i \glossaryItem{diagrammi} dei \glossaryItem{casi} d'uso verrà utilizzato il linguaggio \textit{UML 2.0},
				noto a tutti i membri del gruppo in quanto trattato durante il corso
				di \textit{Ingegneria del Software}.
				Si \`e scelto inoltre di adottare l'editor \glossaryItem{UML} \textit{Astah}.   %riferimento per astah
                                Per mantenere la tracciabilità dei \glossaryItem{casi} d'uso si è deciso di adottare l'utilizzo di \textit{Tracy} come base di dati.
			
			
		\paragraph*{2. Attività di Progettazione}
			\paragraph*{Scopo}
		     %Costruzione a priori perseguendo la correttezza per costruzione
		     %invece che inseguendo la correttezza per correzione     <<  slide PROGETTAZIONE
		     %Procede dall'Analisi dei Requisiti   <<  slide PROGETTAZIONE	
		        La presente attivit\`a, che procede dall'Analisi dei Requisiti, persegue l'obiettivo
		        della correttezza del prodotto per costruzione, permettendo di ridurre al minimo le attività di correzione
		        in \glossaryItem{fase} di codifica.
                        I documenti elaborati in questa \glossaryItem{fase} sono:
                        \begin{itemize}
                        \item \glossaryItem{Specifica Tecnica}, documento proposto in sede di \textit{Revisione di Progettazione minima}, nel quale vengono individuate 
			 le componenti macroscopiche del sistema, suddivisione utile per garantire che il lavoro successivo proceda in modo parallelo e soddisfi i principi di ortogonalità;
                        \item \glossaryItem{Definizione di Prodotto}, documento che fornisce ai \glossaryItem{programmatori} tutte le direttive necessarie per la codifica;
					    esso descrive in dettaglio la progettazione del sistema, integrando quanto scritto nella Specifica Tecnica. Il documento specifica i \glossaryItem{diagrammi} \glossaryItem{UML} e le
					    definizioni delle classi. Viene proposto in sede di \textit{Revisione di Progettazione massima} oppure in sede di \textit{Revisione di Qualifica}.
                        \end{itemize}
		    %si useranno Design patterns
		        Per la progettazione del prodotto sarà opportuno utilizzare \glossaryItem{design pattern} globalmente affermati.
			I membri del gruppo hanno acquisito conoscenze approfondite di tali design pattern durante il corso di \textit{Ingegneria del Software}.
                 
                        %diagrammi \glossaryItem{UML} prodotti
                        \paragraph*{Diagrammi prodotti}
                        Nel corso di questa \glossaryItem{fase} verranno prodotti quattro tipi di \glossaryItem{diagrammi} \glossaryItem{UML}:
                        \begin{itemize}
                        \item \glossaryItem{Diagrammi} delle classi;
                        \item \glossaryItem{Diagrammi} dei \glossaryItem{package};
                        \item \glossaryItem{Diagrammi} di sequenza;
                        \item \glossaryItem{Diagrammi} di attivit\`a.
                        \end{itemize}
                        I tipi di \glossaryItem{diagrammi} sopra elencati andranno a far parte dei due documenti menzionati sopra.
		
			\paragraph*{Tracciamento dei componenti}
			Ogni requisito deve essere riferito al componente che lo soddisfa. Tramite questa operazione è possibile garantire che ogni requisito venga
			soddisfatto, inoltre questo aiuta nella misurazione del progresso dell'attività di progettazione.		
			
		 %parlare degli STRUMENTI utilizzati
		        \paragraph*{Strumenti}
		        Come per l'attivit\`a precedente e per gli stessi motivi, i membri del gruppo hanno stabilito l'utilizzo del linguaggio \glossaryItem{UML} 2.0 per i seguenti
		        \glossaryItem{diagrammi}:
		        \begin{itemize}
			\item \glossaryItem{Diagrammi} dei \glossaryItem{package}; 
			\item \glossaryItem{Diagrammi} delle \textit{classi};	
			\item \glossaryItem{Diagrammi} di \textit{attivit\`a}.
		        \end{itemize}
                        Anche in questo caso per mantenere una tracciabilità viene utilizzato \textit{Tracy} come base di dati per poter mantenere tutti i \glossaryItem{diagrammi} prodotti e la loro descrizione.
			 
		
		\paragraph*{3. Attività di Codifica}

                \paragraph*{Scopo}
                La presente attivit\`a ha come scopo la traduzione in \glossaryItem{codice sorgente} dei risultati ottenuti in sede
                di \glossaryItem{Specifica Tecnica} e di \glossaryItem{Definizione di Prodotto}.
                In sede di \textit{Revisione di Qualifica} \`e possibile fornire una visione precisa sulla attivit\`a.
                Per il codice \glossaryItem{Typescript} si \`e stabilito di adottare delle direttive proprie del gruppo, definite tramite l'uso di un lint.
                \paragraph*{Regole definite nel lint}
                Si \`e deciso di utilizzare il lint per Typescript, \textit{TsLint}, che permette di impostare regole di codifica controllate staticamente.
                Questo lint \`e configurabile tramite l'utilizzo di un file \glossaryItem{JSON}, di cui sono state utilizzate le seguenti regole:
                \begin{itemize}

                \item \textit{member-access}: questa regola impone di dichiarare esplicitamente la visibilit\`a dei membri di una classe;
                \item \textit{member-ordering}: questa regola impone un ordinamento consistente dei membri delle classi, per fornire una lettura del codice pi\`u facile e maggiormente navigabile. In particolare, \`e stato deciso di scrivere prima le variabili e dopo i metodi, e per i metodi, prima quelli pubblici e poi quelli privati;
                \item \textit{no-any}: questa regola impedisce la dichiarazione di variabili di tipo \textit{any} nel codice Typescript, eliminando di fatto la non determinazione di tipo a \textit{static time};
                \item \textit{no-internal-module}: questa regole impedisce l'uso di \glossaryItem{moduli} interni, che portano confusione all'interno del codice. \`E invece imposto l'utilizzo della \textit{keyword} \textit{namespace};
                \item \textit{no-var-requires}: questa regola impedisce l'utilizzo della \textit{keyword} Javascript \textit{require}, per favorire l'utilizzo della nuova \textit{keyword} \textit{import} introdotta da Typescript;
                \item \textit{typedef}: questa regola impone di definire i tipi per metodi di ritorno, parametri, definizioni di variabili e di membri di classi;
                \item \textit{typedef-whitespace}: questa regola impone di inserire degli spazi tra il tipo dichiarato e il suo nome, in maniera tale da aumentare la leggibilit\`a del codice;
                \item \textit{curly}: questa regola impone l'utilizzo di parentesi graffe anche per \textit{statements} condizionali con istruzioni da una riga. Questo permette una maggiore leggibilit\`a del codice e contribuisce a mantenerlo ordinato e a prevenire errori;
                \item \textit{no-bitwise}: questa regola disabilita l'utilizzo delle cosiddette operazioni \textit{bitwise} all'interno di espressioni. Questo viene fatto poiché le operazioni bitwise sono spesso fonte di errore e degradano la leggibilit\`a e la manutenibilità del codice, rendendolo pi\`u confusionario.
                \item \textit{no-conditional-assignment}: questa regola impedisce di poter assegnare valori a una variabile all'interno di espressioni condizionali (di tipo \textit{do-while}, \textit{if}, \textit{for} e \textit{while}). Queste operazioni sono molto spesso pericolose e sono fonte di errori;
                \item \textit{no-duplicate-key}: questa regola impedisce la dichiarazioni di \textit{object literals} con la stessa chiave;
                \item \textit{no-duplicate-variable}: questa regola impedisce la dichiarazioni di variabile con lo stesso nome nello stesso \textit{scope}, evitando ridichiarazioni del compilatore e quindi evitando errori identificabili solamente a tempo di esecuzione;
                \item \textit{no-empty}: questa regola impedisce l'utilizzo di blocchi vuoti di codice, in quanto potrebbero indicare del codice mancante, non implementato (e fonte d'errore);
                \item \textit{no-eval}: questa regola impedisce l'uso della funzione \textit{eval()} in Typescript, in quanto \`e ritenuta pericolosa dal punto di vista della sicurezza e pu\`o permettere l'esecuzione arbitraria di codice passato come una stringa;
                \item \textit{no-null-keyword}: questa regola impedisce l'uso della \textit{keyword} \textit{null} in favore dell'utilizzo della \textit{keyword} \textit{undefined}. Questo permette di uniformare il codice con l'utilizzo di una sola \textit{keyword};
                \item \textit{no-string-literal}: questa regola impedisce l'accesso ad oggetti tramite \textit{string literals}, incoraggiando l'utilizzo delle propriet\`a di accesso di tipo fortemente tipate;
                \item \textit{no-swith-case-fall-through}: questa regola impedisce l'utilizzo di \textit{switch} senza l'utilizzo della \textit{keyword} \textit{break} per ogni caso. In questa maniera si evitano errori in cui tutti i \glossaryItem{casi} successivi a quello voluto vengono eseguiti involontariamente;
                \item \textit{no-unreachable}: questa regola impedisce la scrittura di codice dopo gli \textit{statements: break, catch, throw, return}, che sarebbe non raggiungibile. In questa maniera \`e pi\`u facile riconoscere eventuali errori logici al \glossaryItem{programmatore};
                \item \textit{no-unused-expression}: questa regola impedisce la dichiarazione di oggetti senza un loro effettivo utilizzo. 
                \item \textit{no-use-before-declare}: questa regola impedisce l'utilizzo di variabili senza prima una loro dichiarazione. Questo tipo di codifica di solito porta a errori e all'inquinamento dello \textit{scope} globale, creando quindi confusione nel codice e una minore leggibilit\`a;
                \item \textit{no-var-keyword}: questa regola disabilita la dichiarazione di variabili tramite la \textit{keyword} \textit{var}, ma impone l'utilizzo di \textit{let} per la dichiarazione di variabili, come consigliato da Typescript;
                \item \textit{switch-default}: questa regola impone che quando uno \textit{switch} viene utilizzato sia sempre definito il caso \textit{default};
                \item \textit{use-strict}: questa regola impone l'utilizzo della \textit{keyword} \textit{use-strict} definita nello standard ECMAScript 5;
                \item \textit{eofline}: questa regola impone l'inserimento di una linea vuota alla fine del file, per seguire la convenzione UNIX;
                \item \textit{ident}: questa regola impone l'indentazione tramite spazi e non tramite tabulazioni;
                \item \textit{max-line-length}: questa regola impone la lunghezza massima di una riga a 80 colonne. Questo aiuta a mantenere uniformit\`a al codice e ne facilita di molto la lettura;
                \item \textit{no-require-imports}: questa regola disabilita l'uso della \textit{keyword} \textit{require};
                \item \textit{no-trailing-whitespace}: questa regola impone che nelle righe vuote non siano presenti spazi o tabulazioni;
                \item \textit{trailing-comma}: questa regola impone l'utilizzo della virgola negli \textit{array} e negli \textit{object literals};
                \item \textit{align}: questa regola impone che sia presente un allineamento uniforme tra le varie istruzioni del codice, per facilitarne la lettura;
                \item \textit{class-name}: questa regola impone che i nomi delle classi e delle interfacce seguano la notazione \textit{PascalCased};
                \item \textit{comment-format}: questa regola impone un determinato stile per i commenti. Tutti i commenti devono iniziare con uno spazio e devono iniziare con la lettera maiuscola. Questa regola tenta di dare uniformit\`a a tutti i commenti presenti nel codice;
                \item \textit{jsdoc-format}: questa regola impone lo stile \textit{JSDoc} per i commenti confacenti alla documentazione di una determinata classe o per un determinato metodo;
                \item \textit{one-line}: questa regola impone che una singola istruzione sia presente su una riga e non venga mandata a capo, per migliorare la lettura del codice;
                \item \textit{quotemark}: questa regola impone l'utilizzo di doppi apici durante la stesura di tutto il codice;
                \item \textit{semicolon}: questa regola impone l'utilizzo del punto e virgola alla fine di ogni istruzione in cui andrebbe posta. Questo permette di evitare errori in \glossaryItem{fase} di codifica e di facilitare la lettura del codice;
                \item \textit{variable-name}: questa regola impone che i nomi delle variabili seguano la notazione \textit{camelCase}. Inoltre viene anche vietato che i nomi delle variabili corrispondano a eventuali \textit{keywords};
                  \item \textit{whitespace}: questa regola impone l'inserimento di spazi in vari punti del codice, facilitando la lettura dello stesso e aiutando a mantenere uno stile uniforme.
                \end{itemize}

                
                La scelta e l'utilizzo delle precedenti regole sono strettamente correlati alla teoria sull'\textit{Analisi Statica}, in quanto da essa si evince che:
                \begin{itemize}
		  \item L’adozione di \textit{standard} di codifica deve essere coerente con la scelta dei metodi di \glossaryItem{verifica} adottati,         
                     %<<< slide 30/30 di ANALISI_STATICA
		  \item L’\glossaryItem{efficacia} dei metodi di analisi statica \`e strettamente correlata alla qualit\`a di strutturazione del codice.
                \end{itemize}

		\paragraph*{\textit{10 regole d'oro}}
		Perseguendo l'obiettivo della semplificazione dell'analisi (sia statica sia dinamica),
           	i \glossaryItem{programmatori} del gruppo cercheranno di essere quanto più conformi possibile alle 10 regole
           	espresse nel documento \textit{The Power of 10: Rules for Developing Safety-Critical Code}, che riportiamo di seguito per comodità:
                	\begin{enumerate}
                        	\item \textit{Usare costrutti di controllo di flusso i più semplici possibile}
                        	\item \textit{Usare \glossaryItem{iterazioni} con limite superiore statico}
                        	\item \textit{Non usare allocazione dinamica di memoria dopo l'inizializzazione}
                        	\item \textit{Limitare la lunghezza di ogni singolo sottoprogramma a 60 linee}
                        	\item \textit{Controllare che tutti i parametri in ingresso e in uscita siano validi}
                        	\item \textit{Limitare al massimo la compilazione condizionale}
                        	\item \textit{Puntare ad un uso intensivo di asserzioni(almeno 2 per sottoprogramma)}
                        	\item \textit{Puntare al massimo livello architetturale di \textit{data hiding}}
                        	\item \textit{Limitare al massimo l'uso dei puntatori e il livello di dereferenziazione}
                        	\item \textit{Il codice va compilato da subito usando il compilatore nel modo più restrittivo}
			\end{enumerate}


                \paragraph*{Strumenti}
                Il gruppo ha stabilito di utilizzare i seguenti editor:
                \begin{itemize}
                  \item \textbf{Emacs}(\url{https://www.gnu.org/software/emacs/}) per la stesura del codice \LaTeX; 
                  \item \textbf{WebStorm}(\url{https://www.jetbrains.com/webstorm/}) per il codice \glossaryItem{Typescript}.
                \end{itemize}
             
\subsubsection{Procedure automatiche}
\paragraph{JSDoc} \mbox{} \\
Per guidare la codifica e rendere più chiaro lo scopo di ciascun componente (metodo o classe), il team utilizza la documentazione inline realizzata con JSDoc: JSDoc sfrutta delle annotazioni simili a JavaDoc per documentare il codice direttamente nei file sorgenti. A partire da questa documentazione viene generato, attraverso TypeDoc, un sito web contentente il riepilogo di ciascun componente codificato. È pertanto necessario attenersi ad alcune regole, in modo tale da generare una documentazione facilmente consultabile, consistente e precisa. Di seguito verranno specificate tali regole.
\paragraph*{File}
I file dovranno avere la seguente intestazione:
\begin{verbatim}
/**
 * Descrizione della classe contenuta nel file.
 *
 * * @history
 * |      Author     | Action Performed |      Data      |
 * |       ---       |        ---       |       ---      |
 * | Nome Componente |      Azione      |      Data	     |
 *
 * @author Autore iniziale
 * @license MIT
 */
\end{verbatim}
In questo modo verrà generata un'intestazione comune che consente di tenere sotto controllo le modifiche ai file.
\paragraph*{Campi dati}
Ogni attributo della classe dovrà essere preceduto dalla seguente intestazione:
\begin{verbatim}
/**
 * @description Descrizione dell'attributo
 */
\end{verbatim}
In questo modo sarà possibile disporre di una descrizione dell'attributo, e quindi di avere una chiara indicazione sul suo utilizzo.
\paragraph*{Metodi}
Ogni metodo presente nelle classi dovrà essere preceduto dalla seguente intestazione:
\begin{verbatim}
/**
 * @description Descrizione generale del metodo.
 * @param nomeParametro {tipoParametro} Descrizione del parametro.
 * @returns {tipoDiRitorno} Descrizione del valore ritornato.
 */
\end{verbatim}
In questo modo è possibile conoscere immediatamente lo scopo del metodo, i dati generali sui parametri e sul valore ritornato.
\paragraph*{Costruttore}
Il costruttore della classe dovrà essere preceduto dalla seguente intestazione:
\begin{verbatim}
/**
 * @description Descrizione.
 * @param nomeParametro {tipoParametro} Descrizione del parametro.
 * @constructor
 */
\end{verbatim}
Diversamente da un generico metodo della classe, quindi, il costruttore non presenta valore di ritorno, ma presenta un'annotazione specifica per indicare che si tratta di un costruttore.

\paragraph{APIDoc} \mbox{} \\
Essendo MaaS basato su delle API REST, il team documenta anche le API esposte dal server. Tale documentazione viene realizzata con l'aiuto di APIDoc, che consente di specificare qualsiasi informazione possa servire a codificare, o modificare, lo specifico servizio esposto dal server. Anche in questo caso viene generato, automaticamente, un sito web che consente di consultare la documentazione associata, ed è pertanto necessario regolamentare le annotazioni da utilizzare per la documentazione. Di seguito viene presentato un esempio.
\begin{verbatim}
/**
 * @api {MetodoHTTP} URL corrispondente all'endpoint sul server
 * Breve descrizione del servizio offerto.
 * @apiVersion Versione
 * @apiName Nome del metodo che implementa il servizio
 * @apiGroup Nome del gruppo di API, usato per raggruppare i servizi 
 *           esposti.
 * @apiPermission Livello minimo dell'utente.
 *
 * @apiDescription Descrizione del servizio offerto.
 *
 * @apiParam {tipoParametro1} nomeParametro1 Descrizione del parametro 1.
 * @apiParam {tipoParametroN} nomeParametroN Descrizione del parametro N.
 *
 * @apiExample Example usage:
 * Esempio d'uso del servizio. Eventualmente specificando esempi dei 
 * valori dei parametri.
 *
 * @apiSuccess {tipoValoreRitornato1} Descrizione del valore ritornato 1.
 * @apiSuccess {tipoValoreRitornato2} Descrizione del valore ritornato 2.
 * @apiSuccess {tipoValoreRitornatoM} Descrizione del valore ritornato M.
 *
 * @apiError nomeErrore Descrizione dell'errore.
 * @apiError nomeALtroErrore Descrizione dell'altro errore.
 *
 * @apiErrorExample Response (example):
 *     HTTP/1.1 404
 *     {
 *       "done": false,
 *       "error": "Cannot get companies data"
 *     }
 */
\end{verbatim}
Dove \textit{MetodoHTTP} (\textbf{H}yper\textbf{T}ext \textbf{T}ransfer \textbf{P}rotocol) può assumere uno dei seguenti valori:
\begin{itemize}
\item GET;
\item POST;
\item PUT;
\item DELETE.
\end{itemize}
Inoltre, il numero di @apiParam, @apiSuccess e @apiError è totalmente arbitrario e dipendente dal numero di parametri richiesti, dei valori ritornati, in un oggetto JSON (\textbf{J}ava\textbf{S}cript \textbf{O}bject \textbf{N}otation), e dei tipi di errori che possono essere sollevati.